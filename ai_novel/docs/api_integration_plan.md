# API不整合解消プロジェクト実装計画

## 概要

現在、フロントエンドとバックエンドのAPI仕様に不整合があり、安定した通信ができない状態です。このドキュメントでは、API不整合を解消し、システム全体の安定性を向上させるための具体的な実装計画を記載します。

## 現状の問題点

### 1. エピソード関連のエンドポイント不整合

#### 1.1 個別エピソード取得の不整合

- **バックエンド**: `/acts/<int:act_id>/episodes/<int:pk>/`
- **フロントエンド**:

```typescript
getEpisode: async (storyId: string | number, episodeId: string | number): Promise<ApiResponse<Episode>> => {
  return fetchApi<Episode>(`/acts/${storyId}/episodes/${episodeId}/`)
}
```

- **問題点**: フロントエンドでは `storyId` を `act_id` として使用しており、根本的に誤った参照をしています。バックエンドでは幕(Act)のIDを期待していますが、フロントエンドはストーリーIDを送信しています。

#### 1.2 エピソードコンテンツのエンドポイント

- **バックエンド**: `/episodes/<int:episode_id>/content/`
- **フロントエンド**の実装では、不要な `storyId` パラメータが存在します。

### 2. プロット詳細取得の不整合

- **バックエンド**: あらすじ詳細(ActDetail)は `/stories/<int:story_id>/acts/` で取得
- **フロントエンド**:

```typescript
getPlot: async (storyId: string | number): Promise<ApiResponse<PlotDetail>> => {
  return fetchApi<PlotDetail>(`/stories/${storyId}/basic-setting/`)
}
```

- **問題点**: フロントエンドは「プロット」を基本設定から取得しようとしていますが、バックエンドではこれは別のエンドポイント（acts）で提供されています。

### 3. 一貫性のないAPI呼び出し手法

- フロントエンドコードでは一部の関数（例：`getCharacterDetails`）が共通の `fetchApi` ヘルパー関数を使わず、直接 `fetch` を呼び出しています。
- これにより、エラーハンドリングやレスポンス形式に一貫性がなくなっています。

### 4. インターフェース定義の不一致

- フロントエンドの型定義（`types.ts`）とバックエンドのシリアライザーが完全に一致していない可能性があります。
- 特に、スネークケース（バックエンド）とキャメルケース（フロントエンド）の変換が一部で適切に行われていない可能性があります。

## 実装フェーズ

### 第1フェーズ: フロントエンドとバックエンドのAPI仕様書作成

**目的**: 全てのAPIエンドポイントとフロントエンドの呼び出し関数を明確に文書化し、不整合を特定します。

**タスク**:

1. バックエンドのすべてのAPIエンドポイントを洗い出し、URLパターン、入力パラメータ、レスポンス形式をドキュメント化
2. フロントエンドのAPI呼び出し関数を分析し、使用しているエンドポイント、パラメータ、期待するレスポンス形式をドキュメント化
3. バックエンドとフロントエンドの対応関係を明確にし、不整合箇所を特定
4. 各エンドポイントの用途と期待される動作をドキュメント化

**成果物**:

- 完全なAPIエンドポイント一覧（バックエンド）
- API呼び出し関数一覧（フロントエンド）
- 不整合箇所の一覧と修正方針

### 第2フェーズ: エピソード関連のエンドポイント不整合修正

**目的**: エピソード関連のAPIエンドポイントと呼び出し関数の不整合を解消します。

**タスク**:

1. エピソード取得関数の修正:

```typescript
// 修正後
getEpisode: async (actId: string | number, episodeId: string | number): Promise<ApiResponse<Episode>> => {
  return fetchApi<Episode>(`/acts/${actId}/episodes/${episodeId}/`)
}
```

2. エピソードコンテンツ取得関数の修正:

```typescript
// 修正後
getEpisodeContent: async (episodeId: string | number): Promise<ApiResponse<EpisodeContent>> => {
  return fetchApi<EpisodeContent>(`/episodes/${episodeId}/content/`)
}
```

3. フロントエンドのコンポーネントでこれらの関数を呼び出している箇所の修正
4. ユニットテストおよび統合テストの実施

**成果物**:

- 修正済みのAPI呼び出し関数
- 修正済みのコンポーネント
- テスト結果レポート

### 第3フェーズ: プロット詳細取得の不整合修正

**目的**: プロット（あらすじ）詳細の取得APIの不整合を解消します。

**タスク**:

1. プロット取得関数の修正:

```typescript
// 修正後
getPlot: async (storyId: string | number): Promise<ApiResponse<PlotDetail[]>> => {
  return fetchApi<PlotDetail[]>(`/stories/${storyId}/acts/`)
}
```

2. フロントエンドのコンポーネントでこれらの関数を呼び出している箇所の修正
3. プロット関連データモデルとインターフェースの整合性確認
4. 必要に応じてバックエンドAPIのレスポンス形式の調整
5. ユニットテストおよび統合テストの実施

**成果物**:

- 修正済みのAPI呼び出し関数
- 修正済みのコンポーネント
- テスト結果レポート

### 第4フェーズ: API呼び出し手法の統一

**目的**: すべてのAPI呼び出しで `fetchApi` ヘルパー関数を使用し、エラーハンドリングと応答形式を一貫させます。

**タスク**:

1. 直接 `fetch` を使用している関数の特定:

- `getCharacterDetails`
- `getCharacterDetail`
- `createCharacterDetail`
- `updateCharacterDetail`
- `deleteCharacterDetail`
- `generateCharacterWithAI`

2. これらの関数を `fetchApi` ヘルパー関数を使用するよう修正:

```typescript
// 修正例
export const characterApi = {
  // 既存の関数...

  // 修正後
  getCharacterDetails: async (storyId: string | number): Promise<ApiResponse<Character[]>> => {
    return fetchApi<Character[]>(`/stories/${storyId}/characters/`)
  }
}
```

3. エラーハンドリングの一貫性確保
4. レスポンス形式の統一
5. ユニットテストおよび統合テストの実施

**成果物**:

- 修正済みのAPI呼び出し関数
- 統一されたエラーハンドリングロジック
- テスト結果レポート

### 第5フェーズ: フロントエンドの型定義整備

**目的**: フロントエンドの型定義をバックエンドのシリアライザーと一致させ、命名規則の不一致を解消します。

**タスク**:

1. バックエンドのシリアライザーとフロントエンドの型定義の比較
2. 不一致の箇所を特定
3. フロントエンドの型定義を更新:

```typescript
// 修正例
export interface Episode {
  id: number;
  actId: number; // バックエンドでは act_id
  episodeNumber: number; // バックエンドでは episode_number
  title: string;
  content: string;
  rawContent: string; // バックエンドでは raw_content
  isEdited: boolean; // バックエンドでは is_edited
  createdAt: string; // バックエンドでは created_at
  updatedAt: string; // バックエンドでは updated_at
}
```

4. キャメルケース⇔スネークケース変換のユーティリティ関数を改善
5. 型定義の適用とテスト

**成果物**:

- 更新された型定義ファイル
- 命名規則変換ユーティリティ
- テスト結果レポート

### 第6フェーズ: 統合テストと最終確認

**目的**: すべての修正を統合してテストし、全体的な動作を確認します。

**タスク**:

1. すべての修正済みエンドポイントの統合テスト
2. ユーザーフロー全体でのAPI連携テスト
   - 小説作成フロー
   - 基本設定生成フロー
   - キャラクター詳細生成フロー
   - あらすじ詳細生成フロー
   - エピソード詳細生成フロー
   - エピソード本文生成フロー
3. エラーケースのテスト
   - ネットワークエラー
   - 認証エラー
   - バリデーションエラー
4. パフォーマンス確認
   - レスポンスタイム
   - メモリ使用量
   - レンダリングパフォーマンス

**成果物**:

- 統合テスト結果レポート
- パフォーマンス測定結果
- 最終的な安定性評価

## タイムライン

各フェーズに対する予想作業時間:

1. **第1フェーズ**: 2日間
2. **第2フェーズ**: 1日間
3. **第3フェーズ**: 1日間
4. **第4フェーズ**: 1日間
5. **第5フェーズ**: 2日間
6. **第6フェーズ**: 2日間

**合計**: 約9日間（予備日を含む）

## リスクと対策

1. **リスク**: APIエンドポイントの変更がユーザーエクスペリエンスに影響を与える可能性
   - **対策**: 変更前と変更後の両方のエンドポイントを一時的にサポートし、段階的に移行

2. **リスク**: 型定義の変更が広範囲のコードに影響を与える可能性
   - **対策**: 型定義の変更を慎重に行い、影響範囲を事前に評価

3. **リスク**: 統合テスト中に新たな問題が発見される可能性
   - **対策**: 予備日を確保し、問題発見時に迅速に対応できるようにする

## 成功基準

1. すべてのAPIエンドポイントとフロントエンド呼び出し関数が一貫性をもって動作すること
2. エラーハンドリングが統一され、ユーザーフレンドリーなエラーメッセージが表示されること
3. すべてのユーザーフローが中断なく完了できること
4. レスポンスタイムとパフォーマンスが許容範囲内であること
5. 型の安全性が確保され、型エラーが発生しないこと

## おわりに

この実装計画に従って作業を進めることで、フロントエンドとバックエンドのAPI連携における不整合を解消し、システム全体の安定性と信頼性を向上させることができます。各フェーズで綿密なテストを行い、問題を早期に発見して対処することが重要です。

## 追加：新APIルーティング設計（2025/3/14）

これまでの実装と検証の結果、フロントエンドAPIのルーティング設計における新たな方針を確立しました。具体的には、Next.jsのネストされた動的ルートでの課題を解決するために、クエリパラメータを活用したアプローチを採用します。

### 新しいAPIエンドポイント形式

#### バックエンド（Django）

バックエンドでは引き続きRESTfulなルーティングを維持します：

```
/api/stories/{id}/basic-setting-data/  # 基本設定作成用データ
/api/stories/{id}/characters/          # キャラクター一覧
/api/stories/{id}/is_live/             # 疎通確認用
```

#### フロントエンド（Next.js）

フロントエンドでは、より単純で安定したクエリパラメータ形式を採用します：

```
/api/story-basic-setting-data?id={id}  # 基本設定作成用データ
/api/story-characters?id={id}          # キャラクター一覧
/api/story-is-live?id={id}             # 疎通確認用
```

この新しい形式は、テスト（`test_story_is_live.ts`）により検証済みで、安定性が確認されています。

詳細なガイドラインは [APIルーティングのベストプラクティス](/ai_novel/docs/api_routing_best_practices.md) を参照してください。
